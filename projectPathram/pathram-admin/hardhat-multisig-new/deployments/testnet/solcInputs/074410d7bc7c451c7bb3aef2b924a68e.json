{
  "language": "Solidity",
  "sources": {
    "contracts/MultiSignatureWallet.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\npragma solidity ^0.5.0;\r\n \r\ncontract MultiSignatureWallet {\r\n \r\n  //enum test{Accepted,Rejected,Pending} \r\n    struct Transaction {\r\n      bool executed;\r\n      bool accepted;\r\n      address destination;\r\n      uint value;\r\n      bytes data;\r\n      mapping(address => bool) testing;\r\n    }\r\n \r\n    event Deposit(address indexed sender, uint value);\r\n    event Submission(uint indexed transactionId);\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n \r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n    \texternal\r\n        payable\r\n        \r\n    {\r\n        if (msg.value > 0) {\r\n            emit Deposit(msg.sender, msg.value);\r\n\t    }\r\n    }\r\n \r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.  \r\n \r\n    address[] public owners;\r\n    uint public required;\r\n    mapping (address => bool) public isOwner;\r\n \r\n    uint public transactionCount;\r\n    mapping (uint => Transaction) public transactions;\r\n \r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n \r\n    mapping (uint => mapping (address => bool)) public acceptance;\r\n    //temp\r\n \r\n \r\n \r\n    constructor(address[] memory _owners, uint _required) public payable\r\n        validRequirement(_owners.length,_required) {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n \r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (_required > ownerCount || _required == 0 || ownerCount == 0)\r\n            revert();\r\n        _;\r\n    }  \r\n \r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    //function submitTransaction(address destination, uint value, bytes memory data) public returns (uint transactionId) {}\r\n \r\n    function submitTransaction(address destination, uint value, bytes memory data) \r\n        public payable\r\n        returns (uint transactionId) \r\n    {\r\n        require(isOwner[msg.sender]);\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n \r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n    {\r\n        require(isOwner[msg.sender]);\r\n        require(transactions[transactionId].destination != address(0));\r\n        require(confirmations[transactionId][msg.sender] == false);\r\n        confirmations[transactionId][msg.sender] = true;\r\n        // Transaction.testing[msg.sender] = true;\r\n        acceptance[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n \r\nfunction confirmTransactionReject(uint transactionId)\r\n        public\r\n    {\r\n        require(isOwner[msg.sender]);\r\n        require(transactions[transactionId].destination != address(0));\r\n        require(confirmations[transactionId][msg.sender] == false);\r\n        confirmations[transactionId][msg.sender] = true;\r\n        // Transaction.testing[msg.sender] = true;\r\n        acceptance[transactionId][msg.sender] = false;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n \r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId) public {}\r\n \r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n    {\r\n        require(transactions[transactionId].executed == false);\r\n        if (isConfirmed(transactionId)) {\r\n            uint flag=0;\r\n            for(uint i=0;i<required;i++)\r\n            {\r\n                if(acceptance[transactionId][owners[i]] == false)\r\n                    flag=1;\r\n            }           \r\n \r\n            Transaction storage t = transactions[transactionId];\r\n            if(flag==0)\r\n                t.accepted = true;\r\n            t.executed = true;\r\n \r\n            (bool success, bytes memory rdata) = t.destination.call.value(t.value)(t.data);\r\n            if (success)\r\n                emit Execution(transactionId);\r\n            else {\r\n                emit ExecutionFailure(transactionId);\r\n                t.executed = false;\r\n            }\r\n        }\r\n    }\r\n\t\t/*\r\n\t\t * (Possible) Helper Functions\r\n\t\t */\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n \r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes memory data)\r\n        internal\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false,\r\n            accepted:false\r\n        });\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}